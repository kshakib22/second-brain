---
title: 94. Binary Tree Inorder Traversal
date: Thursday, August 8th 2024
tags: Stack, Tree, Depth-First Search, Binary Tree
---
**Difficulty:** #Easy

---

## Problem Statement
> Given the root of a binary tree, return the inorder traversal of its nodes' values.

**Example 1:**
![inorder|center](../assets/inorder_1.jpg)
> `Input: root = [1,null,2,3]`      
> `Output: [1,3,2] `

**Example 2:**

> `Input: root = []`  
> `Output: [] `

**Example 3:**

> `Input: root = [1] `  
> `Output: [1]`


[Problem Link](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

---

## Approach & Explanation

We use [Recursion](../Algorithms/Recursion.md) for the trivial solution of this problem. Check [Tree Traversal Theory](../Data%20Structures/Tree%20Traversal%20Theory.md) for what Inorder traversal is. Basically its Left subtree - Root - Right subtree. Our function for solution calls itself recursively for left subtree and right subtree. 

A list `result` is initialized to collect node values in the correct order.
**Base Case**: If the current node is `None`, an empty list `[]` is returned. 
The `extend()` method is used to add the results from left and right subtrees to `result`. After the recursion completes, the `result` list contains the nodes in inorder sequence.

---

## Solution

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []  # This list will hold the inorder traversal result
        
        if not root:
            return result  # If the root is None, return the empty list
        
        # Recursively traverse the left subtree and extend the result list
        result.extend(self.inorderTraversal(root.left))
        
        # Append the value of the current node
        result.append(root.val)
        
        # Recursively traverse the right subtree and extend the result list
        result.extend(self.inorderTraversal(root.right))
        
        return result
```


### Complexities

**Time Complexity:** $\mathcal{O}(n)$   
**Space Complexity:** $\mathcal{O}(n)$  

For the nodes, we do have to visit all of them to 'traverse' through. In a recursive solution, all the roots are called onto the memory stack so in worst case it is also  $\mathcal{O}(n)$. 


---

## Possible Confusion

1. **Why Doesn’t result Get Messed Up?**

- **Local Scope**: Each recursive call creates a new result list in its *own* scope. When a recursive call returns, the parent function’s result list is extended with the returned values.
- **No Re-initialization**: The `result` list in the parent call (the og one) is not re-initialized or overwritten during recursion, preserving its contents.

2. **Handling Empty Lists with `extend()`**

- Empty Lists: When a subtree has no nodes (None), the recursive call returns an empty list []. Using `extend()` with an empty list has no effect on result, so it remains unchanged.

---
## Further Challenge

>Recursive solution is trivial, could you do it iteratively?

